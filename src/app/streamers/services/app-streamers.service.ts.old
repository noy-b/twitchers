import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

import { Observable, BehaviorSubject, Subject, Subscription } from 'rxjs/Rx';

import { Streamer } from '../models/streamers';
import { SpinnerService } from '../../spinner/services/app-spinner.service';

// Service to get all the streams and form the data
@Injectable()
export class StreamersService {
    private streamersArr = [ 'RockLeeSmile', 'cretetion', 'DanzNewz', 'ladymeowss',
                           'freecodecamp', 'storbeck', 'habathcx', 'Cryaotic',
                           'RobotCaleb', 'noobs2ninjas', 'Northernlion',
                           'GamesDoneQuick', 'LilyPichu', 'sp00nerism',
                            'riotgames', 'esl_csgo', 'imaqtpie', 'gosu'];
    private urlUsers   = `https://api.twitch.tv/kraken/users?login=${this.streamersArr.join(',')}`;
    private urlStreams = `https://api.twitch.tv/kraken/streams/`;
    private urlCovers  = `https://api.twitch.tv/kraken/search/games?query=`;
    private apiKey     = `xdjosvpjf9brwzbkpo37r4ztjogo57`;

    public streamersSub: Subscription;
    public streamersList: Subject<Streamer[]> = new BehaviorSubject<Streamer[]>(null);

    constructor(
        private http: HttpClient,
        private spinnerService: SpinnerService
    ) { }
    // The first request gets all the users
    // 1. .switchMap merges the previous call with the .forkJoin observable
    // 2. .forkJoin makes parallel requests to check if each stream is online
    // 3. .switchMap gets the box art for the live users
    // The results are cast to the Streamer class
    public getStreamers(): Observable<Streamer[]> {
        this.spinnerService.isLoading(true);
        const headers = new HttpHeaders()
            .set('Client-ID', `${this.apiKey}`)
            .set('Accept', 'application/vnd.twitchtv.v5+json');

        return this.http.get(this.urlUsers, { headers })
        .switchMap((userArr: any[]) => {
            return Observable.forkJoin(
            userArr['users'].map((user: any) => {
                return this.http.get(this.urlStreams + user._id, { headers })
                .map((res: any) => {
                    user.online   = res.stream ? true : false;
                    user.gamename = res.stream ? res.stream.game : false;
                    user.viewers  = res.stream ? res.stream.viewers : false;
                    user.uptime   = res.stream ? res.stream.created_at : false;
                    this.spinnerService.isLoading(false);
                    return new Streamer(user);
                })
                .switchMap((res: Streamer) => {
                    if (res.game.name) {
                        return this.http.get(this.urlCovers + res.game.name, { headers })
                        .map((cover: any) => {
                            res.game.cover = cover.games[0].box.medium;
                            return res;
                        });
                    } else {
                        return Observable.of(res);
                    }
                });
            })).map((data: any[]) => data.sort((a, b) => b.status.value - a.status.value));
        }).retryWhen(errors => { console.log(errors); return errors.delay(3000).take(10); });
    }
    // Refresh users' list manually
    public refreshStreamersList(interval: number): Subscription {
        // Avoid multiple requets. If one is going, abort all others.
        if (this.streamersSub) {
            this.streamersSub.unsubscribe();
        }
        return this.pollStreamers(interval);
    }

    // Polling of users' list
    // Update of BehaviorSubject
    public pollStreamers(interval: number): Subscription {
        this.streamersSub = Observable.timer(interval, 60000).switchMap(() => this.getStreamers()).subscribe(data => {
            this.streamersList.next(data);
            this.spinnerService.isLoading(false);
        });
        return this.streamersSub;
    }
    // Errors Handling
    private handleError(error: any): Observable<any> {
        console.error('An error occurred', error);
        return Observable.throw(error.message || error);
    }
}
